# ~/.zshrc for Kubernetes CLI Toolkit

# Enable completion system
autoload -Uz compinit promptinit
compinit
promptinit

# Set up colors
autoload -U colors && colors

# Prompt with kube context + git branch if any
# Load vcs_info for Git status
autoload -Uz vcs_info
precmd() { vcs_info }

# Git info styling
zstyle ':vcs_info:git:*' enable git
zstyle ':vcs_info:git:*' formats '%b'
zstyle ':vcs_info:*' check-for-changes true

# Git summary function
function git_prompt_info() {
  git rev-parse --is-inside-work-tree &>/dev/null || return

  local repo branch ahead behind dirty untracked staged info=""

  # Repo path from remote URL, strip protocol/host and .git
  repo=$(git remote get-url origin 2>/dev/null | sed -E 's#(https?://|git@)[^/:]+[:/]##; s/\\.git$//')
  # Branch name
  branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null)

  # ahead/behind
  local raw=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null)
  ahead=$(echo $raw | awk '{print $2}')
  behind=$(echo $raw | awk '{print $1}')

  # Status symbols
  git diff --quiet --ignore-submodules HEAD &>/dev/null || dirty="‚ú±"
  git diff --cached --quiet --ignore-submodules HEAD &>/dev/null || staged="‚úö"
  [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]] && untracked="‚úñ"

  # Compose info string with colors
  info="%F{blue}[%F{cyan}repo:%f%F{yellow}${repo}%f"
  info+=" %F{cyan}branch:%f%F{yellow}${branch}%f"
  [[ "$ahead" -gt 0 ]] && info+=" %F{green}‚¨Ü$ahead%f"
  [[ "$behind" -gt 0 ]] && info+=" %F{red}‚¨á$behind%f"
  [[ -n "$dirty" ]] && info+=" %F{red}$dirty%f"
  [[ -n "$staged" ]] && info+=" %F{magenta}$staged%f"
  [[ -n "$untracked" ]] && info+=" %F{yellow}$untracked%f"
  info+="%F{blue}]%f"

  echo "$info"
}

# Kubernetes context, namespace, and tanzu context
function kube_prompt_info() {
  local ctx ns tanzu_ctx
  ctx=$(kubectl config current-context 2>/dev/null)
  ns=$(kubectl config view --minify --output 'jsonpath={..namespace}' 2>/dev/null)
  tanzu_ctx=$(tanzu context current --short 2>/dev/null | head -n1)
  if [[ "$tanzu_ctx" == "There is no active context" || -z "$tanzu_ctx" ]]; then
    tanzu_ctx="none"
  fi
  [[ -n "$ctx" ]] && echo "%F{blue}[%F{cyan}cluster:%f%F{yellow}${ctx}%f%F{blue} / %F{cyan}namespace:%f%F{yellow}${ns:-default}%f%F{blue} / %F{cyan}tanzu:%f%F{yellow}${tanzu_ctx}%f%F{blue}]%f"
}

autoload -Uz vcs_info
precmd() { vcs_info }

setopt PROMPT_SUBST

# Final prompt using kube_prompt_info and VCS info
PROMPT='$(kube_prompt_info) $(git_prompt_info)
%F{magenta}‚ò∏Ô∏è%f %% '

# Git info formatting
zstyle ':vcs_info:git:*' formats '%F{red}ÓÇ† %b%f'

# Completion sources
# NOTE: These will be silently skipped if the tool is missing or doesn't support zsh completion
function try_source_completion() {
  if command -v "$1" >/dev/null 2>&1; then
    case "$1" in
      kubectl)
        source <($1 completion zsh)
        ;;
      helm)
        source <($1 completion zsh)
        ;;
      k9s)
        [[ -f /usr/share/zsh/site-functions/_k9s ]] && source /usr/share/zsh/site-functions/_k9s
        ;;
      tanzu)
        source <($1 completion zsh)
        ;;
      velero)
        source <($1 completion zsh)
        ;;
      vendir)
        $1 completion zsh | grep -v '^Succeeded' >/tmp/_${1}_completion.zsh 2>/dev/null && source /tmp/_${1}_completion.zsh
        ;;
      yq)
        source <($1 completion zsh)
        ;;
      ytt|kapp|kbld|imgpkg|kctrl)
        $1 completion zsh >/tmp/_${1}_completion.zsh 2>/dev/null && source /tmp/_${1}_completion.zsh
        ;;
    esac
  fi
}

for tool in kubectl helm k9s tanzu velero ytt kapp kbld imgpkg vendir kctrl; do
  try_source_completion "$tool"
done

# Set PATH and environment variables (if needed)
export PATH="/k8s/bin:$PATH"

# Aliases
alias k=kubectl
alias h=helm
alias t=tanzu

# History
export HISTFILE=${HOME}/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000
setopt INC_APPEND_HISTORY       # Append commands to the history file as they are typed
setopt HIST_IGNORE_DUPS         # Don't record duplicate commands
setopt HIST_REDUCE_BLANKS       # Remove superfluous blanks before recording entry
setopt SHARE_HISTORY            # Share command history across terminals

# Function: versions
versions() {
  # Banner
  echo
  cat /banner.txt
  echo

  echo -e "\033[1;34mWelcome to the Kubernetes CLI Toolkit!\033[0m"
  echo -e "\033[1;34mTools like kubectl, helm, ytt, kapp, k9s and more are ready to go.\033[0m"
  echo

  # Version variables
  v_kubectl=$(kubectl version --client -o json 2>/dev/null | jq -r '.clientVersion.gitVersion')
  v_helm=$(helm version --short 2>/dev/null)
  v_ytt=$(ytt version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kapp=$(kapp version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_k9s=$(k9s version -s 2>&1 | grep -Eo '[0-9.]+' | head -n1)
  v_imgpkg=$(imgpkg version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_tanzu=$(tanzu version | grep ^version | grep -Eo '[0-9.]+' | head -n1)
  v_velero=$(velero version 2>/dev/null | grep -Eo 'v[0-9.]+' | head -n1)
  v_yq=$(yq --version 2>/dev/null | grep -Eo '[0-9.]+$')
  v_vendir=$(vendir version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kbld=$(kbld version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kctrl=$(kctrl version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_image="${IMAGE_VERSION:-unknown}"

  # Fallback to "?" if version is empty
  fallback() { [[ -z "$1" || "$1" == "null" ]] && echo "?" || echo "$1"; }

  # Print header
  echo -e "\033[1;34mInstalled Tool Versions:\033[0m"
  echo

  # Print formatted table
  printf "\033[34m%-12s\033[0m: \033[32m%-16s\033[0m" "kubectl" "$(fallback "$v_kubectl")"
  printf "\033[34m%-12s\033[0m: \033[32m%-24s\033[0m" "helm" "$(fallback "$v_helm")"
  printf "\033[34m%-12s\033[0m: \033[32m%s\033[0m\n" "ytt" "$(fallback "$v_ytt")"

  printf "\033[34m%-12s\033[0m: \033[32m%-16s\033[0m" "kapp" "$(fallback "$v_kapp")"
  printf "\033[34m%-12s\033[0m: \033[32m%-24s\033[0m" "k9s" "$(fallback "$v_k9s")"
  printf "\033[34m%-12s\033[0m: \033[32m%s\033[0m\n" "imgpkg" "$(fallback "$v_imgpkg")"

  printf "\033[34m%-12s\033[0m: \033[32m%-16s\033[0m" "tanzu" "$(fallback "$v_tanzu")"
  printf "\033[34m%-12s\033[0m: \033[32m%-24s\033[0m" "velero" "$(fallback "$v_velero")"
  printf "\033[34m%-12s\033[0m: \033[32m%s\033[0m\n" "yq" "$(fallback "$v_yq")"

  printf "\033[34m%-12s\033[0m: \033[32m%-16s\033[0m" "vendir" "$(fallback "$v_vendir")"
  printf "\033[34m%-12s\033[0m: \033[32m%-24s\033[0m" "kbld" "$(fallback "$v_kbld")"
  printf "\033[34m%-12s\033[0m: \033[32m%s\033[0m\n" "kctrl" "$(fallback "$v_kctrl")"

  echo
  printf "\033[34mImage Version\033[0m: \033[32m%s\033[0m\n" "$v_image"
  printf "\033[34mMaintained by\033[0m: \033[32mdwhicker@bifrost.cc\033[0m\n"
  echo
}

# Function: tanzu_needs_init
# Returns 0 if Tanzu needs initialization, 1 otherwise
function tanzu_needs_init() {
  local tanzu_dir="$HOME/.config/tanzu"
  local config_yaml="$tanzu_dir/config.yaml"
  if [ ! -d "$tanzu_dir" ] || [ -z "$(ls -A "$tanzu_dir" 2>/dev/null)" ]; then
    return 0
  elif [ -f "$config_yaml" ]; then
    # Check if config.yaml contains only '{}', possibly with whitespace
    local content
    content=$(tr -d '\n\r\t ' < "$config_yaml")
    if [ "$content" = "{}" ]; then
      return 0
    fi
  fi
  return 1
}

function tanzu_init() {
  export TANZU_CLI_CEIP_OPT_IN_PROMPT_ANSWER=No
  echo "üîß Initializing Tanzu plugins..."

  tanzu config eula accept

  local plugin_groups=(
    "vmware-tanzucli/essentials"
    "vmware-tmc/default"
    "vmware-tkg/default"
    "vmware-vsphere/default"
  )

  for group in "${plugin_groups[@]}"; do
    echo "üì¶ Installing plugin group: $group"

    # Get current plugins (before install)
    local -a before_plugins
    while IFS= read -r line; do
      before_plugins+=("$line")
    done < <(tanzu plugin list -o json | jq -r '.[] | "\(.name):\(.target)"' | sort -u)

    # Install plugins quietly
    tanzu plugin install all --group "$group" > /dev/null 2>&1

    # Get plugins after install
    local -a after_plugins
    while IFS= read -r line; do
      after_plugins+=("$line")
    done < <(tanzu plugin list -o json | jq -r '.[] | "\(.name):\(.target)"' | sort -u)

    # Compare and count newly added plugins
    local -i new_count=0
    for plugin in "${after_plugins[@]}"; do
      if [[ ! " ${before_plugins[*]} " == *" $plugin "* ]]; then
        ((new_count++))
      fi
    done

    echo "‚úÖ Installed ${new_count} plugins from group: $group"
  done

  echo "üéâ Tanzu plugins initialized successfully."
}

hints() {
  echo -e "

\033[1;33mYou will need to create a Tanzu context to get started.\033[0m
\033[1;36m tanzu tmc context create <context-name> -e <tmc.server.name> -i pinniped\033[0m
\033[1;36m tanzu context create <context-name> -e <tmc.server.name> -i pinniped\033[0m

\033[1;33mOnce you have a context created, you can generate kubeconfigs for each TMC cluster with:\033[0m
\033[1;36m tmc-get-kubeconfigs\033[0m

\033[1;33mTo log in to vSphere Supervisor clusters (vKS, TKGS, etc.), you can use:\033[0m
\033[1;36m kubectl vsphere login --server <vSphere-API-URL> --vsphere-username <username> --insecure-skip-tls-verify\033[0m

"
}

versions
echo
if tanzu_needs_init; then
  tanzu_init
else
  echo "‚ÑπÔ∏è  Tanzu already initialized."
fi
echo
echo "K8s CLI environment loaded.  Type 'hints' for usage tips."
echo
