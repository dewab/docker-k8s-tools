# ~/.zshrc for Kubernetes CLI Toolkit

# Enable completion system
autoload -Uz compinit promptinit
compinit
promptinit

# Set up colors
autoload -U colors && colors

# Prompt with kube context + git branch if any
# Load vcs_info for Git status
autoload -Uz vcs_info
precmd() { vcs_info }

# Git info styling
zstyle ':vcs_info:git:*' enable git
zstyle ':vcs_info:git:*' formats '%b'
zstyle ':vcs_info:*' check-for-changes true

# Git summary function
function git_prompt_info() {
  git rev-parse --is-inside-work-tree &>/dev/null || return

  local repo branch ahead behind dirty untracked staged info=""

  # Repo path from remote URL, strip protocol/host and .git
  repo=$(git remote get-url origin 2>/dev/null | sed -E 's#(https?://|git@)[^/:]+[:/]##; s/\\.git$//')
  # Branch name
  branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null)

  # ahead/behind
  local raw=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null)
  ahead=$(echo $raw | awk '{print $2}')
  behind=$(echo $raw | awk '{print $1}')

  # Status symbols
  git diff --quiet --ignore-submodules HEAD &>/dev/null || dirty="‚ú±"
  git diff --cached --quiet --ignore-submodules HEAD &>/dev/null || staged="‚úö"
  [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]] && untracked="‚úñ"

  # Compose info string with colors
  info="%F{blue}[ %F{cyan}repo: %f%F{yellow}${repo}%f"
  info+=" %F{cyan}branch: %f%F{yellow}${branch}%f"
  [[ "$ahead" -gt 0 ]] && info+=" %F{green}‚¨Ü$ahead%f"
  [[ "$behind" -gt 0 ]] && info+=" %F{red}‚¨á$behind%f"
  [[ -n "$dirty" ]] && info+=" %F{red}$dirty%f"
  [[ -n "$staged" ]] && info+=" %F{magenta}$staged%f"
  [[ -n "$untracked" ]] && info+=" %F{yellow}$untracked%f"
  info+="%F{blue} ]%f"

  echo "$info"
}

# Kubernetes context, namespace, and tanzu context
function kube_prompt_info() {
  local ctx ns tanzu_ctx
  ctx=$(kubectl config current-context 2>/dev/null)
  ns=$(kubectl config view --minify --output 'jsonpath={..namespace}' 2>/dev/null)
  tanzu_ctx=$(tanzu context current --short 2>/dev/null | head -n1)
  if [[ "$tanzu_ctx" == "There is no active context" || -z "$tanzu_ctx" ]]; then
    tanzu_ctx="none"
  fi
  [[ -n "$ctx" ]] && echo "%F{blue}[ %F{cyan}cluster: %f%F{yellow}${ctx}%f%F{blue} / %F{cyan}namespace :%f%F{yellow}${ns:-default}%f%F{blue} / %F{cyan}tanzu: %f%F{yellow}${tanzu_ctx}%f%F{blue} ]%f"
}

autoload -Uz vcs_info
precmd() { vcs_info }

setopt PROMPT_SUBST

# Final prompt using kube_prompt_info and VCS info
# PROMPT=' %F{blue}[ %F{cyan}cwd: %f%F{yellow}${PWD}%f%F{blue} ]%f $(kube_prompt_info) $(git_prompt_info)
# %F{magenta}‚ò∏Ô∏è%f %% '
PROMPT='%{$fg[blue]%}[ %{$fg[cyan]%}cwd: %{$fg[yellow]%}${PWD}%{$reset_color%}%{$fg[blue]%} ]%{$reset_color%} $(kube_prompt_info) $(git_prompt_info)
%{$fg[magenta]%}‚ò∏Ô∏è %{$reset_color%}%% '

# Git info formatting
zstyle ':vcs_info:git:*' formats '%F{red}ÓÇ† %b%f'

# Completion sources
# NOTE: These will be silently skipped if the tool is missing or doesn't support zsh completion
function try_source_completion() {
  if command -v "$1" >/dev/null 2>&1; then
    case "$1" in
      kubectl)
        source <($1 completion zsh)
        ;;
      helm)
        source <($1 completion zsh)
        ;;
      k9s)
        [[ -f /usr/share/zsh/site-functions/_k9s ]] && source /usr/share/zsh/site-functions/_k9s
        ;;
      tanzu)
        source <($1 completion zsh)
        ;;
      velero)
        source <($1 completion zsh)
        ;;
      vendir)
        $1 completion zsh | grep -v '^Succeeded' >/tmp/_${1}_completion.zsh 2>/dev/null && source /tmp/_${1}_completion.zsh
        ;;
      yq)
        source <($1 completion zsh)
        ;;
      ytt|kapp|kbld|imgpkg|kctrl)
        $1 completion zsh >/tmp/_${1}_completion.zsh 2>/dev/null && source /tmp/_${1}_completion.zsh
        ;;
    esac
  fi
}

for tool in kubectl helm k9s tanzu velero ytt kapp kbld imgpkg vendir kctrl; do
  try_source_completion "$tool"
done

# Set PATH and environment variables (if needed)
export PATH="/k8s/bin:$PATH"

# Aliases
alias k=kubectl
alias h=helm
alias t=tanzu

# History
export HISTFILE=${HOME}/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000
setopt INC_APPEND_HISTORY       # Append commands to the history file as they are typed
setopt HIST_IGNORE_DUPS         # Don't record duplicate commands
setopt HIST_REDUCE_BLANKS       # Remove superfluous blanks before recording entry
setopt SHARE_HISTORY            # Share command history across terminals

versions() {
  # Banner
  echo
  cat /banner.txt
  echo

  echo "${fg[blue]}Welcome to the Kubernetes CLI Toolkit!${reset_color}"
  echo "${fg[blue]}Tools like kubectl, helm, ytt, kapp, k9s and more are ready to go.${reset_color}"
  echo

  # Version variables
  v_kubectl=$(kubectl version --client -o json 2>/dev/null | jq -r '.clientVersion.gitVersion')
  v_helm=$(helm version --short 2>/dev/null)
  v_ytt=$(ytt version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kapp=$(kapp version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_k9s=$(k9s version -s 2>&1 | grep -Eo '[0-9.]+' | head -n1)
  v_imgpkg=$(imgpkg version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_tanzu=$(tanzu version | grep ^version | grep -Eo '[0-9.]+' | head -n1)
  v_velero=$(velero version 2>/dev/null | grep -Eo 'v[0-9.]+' | head -n1)
  v_yq=$(yq --version 2>/dev/null | grep -Eo '[0-9.]+$')
  v_vendir=$(vendir version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kbld=$(kbld version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_kctrl=$(kctrl version 2>/dev/null | grep -Eo '[0-9.]+' | head -n1)
  v_image="${IMAGE_VERSION:-unknown}"

  # Fallback to "?" if version is empty
  fallback() { [[ -z "$1" || "$1" == "null" ]] && echo "?" || echo "$1"; }

  # Tool/version arrays
  local tools=(kubectl helm ytt kapp k9s imgpkg tanzu velero yq vendir kbld kctrl)
  local versions=(
    "$(fallback "$v_kubectl")" "$(fallback "$v_helm")" "$(fallback "$v_ytt")" "$(fallback "$v_kapp")"
    "$(fallback "$v_k9s")" "$(fallback "$v_imgpkg")" "$(fallback "$v_tanzu")" "$(fallback "$v_velero")"
    "$(fallback "$v_yq")" "$(fallback "$v_vendir")" "$(fallback "$v_kbld")" "$(fallback "$v_kctrl")"
  )

  # Table border characters (Unicode, but built safely)
  local H="‚îÄ" V="‚îÇ" TL="‚îå" TR="‚îê" BL="‚îî" BR="‚îò" TJ="‚î¨" BJ="‚î¥" CJ="‚îº"
  local w=18 cols=4

  # Build top border (Unicode-safe, no tr/printf hacks)
  local border="${TL}"
  for ((i=1; i<cols; i++)); do
    for ((j=0; j<$w; j++)); do border+="$H"; done
    border+="$TJ"
  done
  for ((j=0; j<$w; j++)); do border+="$H"; done
  border+="$TR"
  echo "${fg[blue]}$border${reset_color}"

  # Print rows (4 columns: tool, version, tool, version)
  while (( ${#tools[@]} )); do
    printf "${fg[blue]}${V}${reset_color}"
    for ((c=1; c<=cols && ${#tools[@]}; c++)); do
      # Print tool name (max 8 chars, left aligned), version (max 9 chars, left aligned)
      printf "%-8s %-9.9s${fg[blue]}${V}${reset_color}" "${tools[1]}" "${versions[1]}"
      tools=("${tools[@]:1}")
      versions=("${versions[@]:1}")
    done
    # Fill remaining columns if not enough tools
    for ((; c<=cols; c++)); do
      printf "%-8s %-9s${fg[blue]}${V}${reset_color}" "" ""
    done
    echo
  done

  # Bottom border (Unicode-safe)
  border="${BL}"
  for ((i=1; i<cols; i++)); do
    for ((j=0; j<$w; j++)); do border+="$H"; done
    border+="$BJ"
  done
  for ((j=0; j<$w; j++)); do border+="$H"; done
  border+="$BR"
  echo "${fg[blue]}$border${reset_color}"

  echo
  printf "${fg[blue]}Maintained by${reset_color}: ${fg[green]}dwhicker@bifrost.cc${reset_color}\n"
  echo
}

# Function: tanzu_needs_init
# Returns 0 if Tanzu needs initialization, 1 otherwise
function tanzu_needs_init() {
  local tanzu_dir="$HOME/.config/tanzu"
  local config_yaml="$tanzu_dir/config.yaml"
  if [ ! -d "$tanzu_dir" ] || [ -z "$(ls -A "$tanzu_dir" 2>/dev/null)" ]; then
    return 0
  elif [ -f "$config_yaml" ]; then
    # Check if config.yaml contains only '{}', possibly with whitespace
    local content
    content=$(tr -d '\n\r\t ' < "$config_yaml")
    if [ "$content" = "{}" ]; then
      return 0
    fi
  fi
  return 1
}

function tanzu_init() {
  export TANZU_CLI_CEIP_OPT_IN_PROMPT_ANSWER=No
  echo "üîß Initializing Tanzu plugins..."

  tanzu config eula accept

  local plugin_groups=(
    "vmware-tanzucli/essentials"
    "vmware-tmc/default"
    "vmware-tkg/default"
    "vmware-vsphere/default"
  )

  for group in "${plugin_groups[@]}"; do
    echo "üì¶ Installing plugin group: $group"

    # Get current plugins (before install)
    local -a before_plugins
    while IFS= read -r line; do
      before_plugins+=("$line")
    done < <(tanzu plugin list -o json | jq -r '.[] | "\(.name):\(.target)"' | sort -u)

    # Install plugins quietly
    tanzu plugin install all --group "$group" > /dev/null 2>&1

    # Get plugins after install
    local -a after_plugins
    while IFS= read -r line; do
      after_plugins+=("$line")
    done < <(tanzu plugin list -o json | jq -r '.[] | "\(.name):\(.target)"' | sort -u)

    # Compare and count newly added plugins
    local -i new_count=0
    for plugin in "${after_plugins[@]}"; do
      if [[ ! " ${before_plugins[*]} " == *" $plugin "* ]]; then
        ((new_count++))
      fi
    done

    echo "‚úÖ Installed ${new_count} plugins from group: $group"
  done

  echo "üéâ Tanzu plugins initialized successfully."
}

hints() {
  echo "
${fg[yellow]}You will need to create a Tanzu context to get started.${reset_color}
${fg[cyan]} tanzu tmc context create <context-name> -e <tmc.server.name> -i pinniped${reset_color}
${fg[cyan]} tanzu context create <context-name> -e <tmc.server.name> -i pinniped${reset_color}

${fg[yellow]}Once you have a context created, you can generate kubeconfigs for each TMC cluster with:${reset_color}
${fg[cyan]} tmc-get-kubeconfigs${reset_color}

${fg[yellow]}To log in to vSphere Supervisor clusters (vKS, TKGS, etc.), you can use:${reset_color}
${fg[cyan]} kubectl vsphere login --server <vSphere-API-URL> --vsphere-username <username> --insecure-skip-tls-verify${reset_color}
"
}

versions
echo
if tanzu_needs_init; then
  tanzu_init
else
  echo "‚ÑπÔ∏è  Tanzu already initialized."
fi
echo
echo "K8s CLI environment loaded.  Type 'hints' for usage tips."
echo
